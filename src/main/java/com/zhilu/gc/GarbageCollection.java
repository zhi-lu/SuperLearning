package com.zhilu.gc;

/**
 * @author apple
 * @version jdk1.8
 *
 * 对于垃圾回收的部分.
 *
 * 什么是垃圾,为什么JVM需要进行垃圾回收:首先垃圾的定义当我们对象不在被引用所指向的时候就满足了垃圾的定义.通俗的来说就是我们
 * 创建的大部分对象是根据程序方法的执行所创建的,我们方法执行完毕我们创建的大部分对象可能就不会在被二次或者多次使用了.
 * 这种对象不会在内存中主动的被清除,导致这类对象在JVM的内存所占的比例越来越多.如果不及时清除,从而会导致其他对象的
 * 创建和JVM工作的性能.所以必须有这么一个东西去清除我们程序中所产生的"垃圾".从而保证我们的JVM能够正常的执行工作.
 * 所以我们JVM的垃圾回收因此而生.
 *
 * 如何判断一个对象是否可以被回收:{
 *     one -> 引用计数法 原理:引用计数法为对象添加一个引用计数器.然后用一块额外的内存空间去保存我们对象被引用的次数.
 *     当对象每有一个地方引用它时,那我们对该对象的引用计数就会加1,反之每有一个引用失效时,我们对该对象的引用计数就会减1,
 *     当对象的引用次数为0时,那么我们可以认为这个对象是不会被再次使用了,通过这种方式我们能快速直观的定位到这些可回收的对象,
 *     从而进行清理.
 *     缺点：i -> 无法解决循环引用的问题:引用计数法虽然很直观高效,但是通过引用计数法是没办法扫描到一种特殊情况下的"可回收"对象,
 *                 这种特殊情况就是对象循环引用的时候,比如A对象引用了B,B对象引用了A,除此之外他们两个没有被任何其他对象引用,
 *                 那么其实这部分对象也属于"可回收"的对象,但是通过引用计数法是没办法定位的.垃圾清理不掉,很容易就出现OOM了,这是很致命的,所以被淘汰掉了.
 *          ii -> 另外一个方面是引用计数法需要额外的空间记录每个对象的被引用的次数,这个引用数也需要去额外的维护.
 *
 *     two -> 可达性分析法 原理:可达性分析法是通过以所有的"GC Roots"对象为出发点,如果无法通过GC Roots的引用追踪到的对象,那我们认为这些对象就不会再次被使用了.
 *                           现在主流的程序语言都是通过可达性分析法来判断对象是否存活的.
 *                       <============================================================================>
 *                       哪些对象对象我们称之为"GC Roots"对象呢? 当然普通的对象肯定是不行的,如果要作为GC Roots 对象那么它自身肯定得满足一个条件,
 *                       那就是他自己一定在很长一段时间内都不会被GC 回收掉.那么只有满足这个条件的对象才可能作为GC Roots了.
 *                       GC Roots的类型大致如下:{
 *                           i    -> 虚拟机栈中的本地变量所引用的对象.
 *                           ii   -> 方法区中静态属性所引用的对象.
 *                           iii  -> 方法去中常量属性所引用的对象
 *                           iv   -> 本地方法(Native方法)引用的对象
 *                           v    -> 虚拟机内部的引用对象(类加载器,基本数据对应的Class对象,异常对象)
 *                           vi   -> 所有被同步锁(Synchronized)持有的对象.
 *                           vii  -> 描述虚拟机内部情况的对象.
 *                           viii -> 垃圾搜集器所引用的对象
 *                       }
 * }
 *
 * 首先GarbageCollection(垃圾回收)依托垃圾回收算法和相关的垃圾回收器.
 * 四种垃圾回收算法{
 *    one -> 标记-清除回收算法
 *      可分为两步{
 *          第⼀步:标记出可以回收的对象.
 *          第⼆步:统⼀清理可以回收的对象内存.
 *          }
 *      缺点:⾸先标记和清除步骤效率都不⾼,其次会产⽣内存碎⽚.
 *
 *    two -> 复制回收算法:
 *      将内存分为(⼤⼩相等)两部分,每次只使⽤其中⼀块进⾏内存分配,当内存使⽤完后,就出发GC,
 *      将存活的对象直接复制到另⼀块空闲的内存中,然后对当前使⽤的内存块⼀次性清除所有,然后转到另⼀块内存进⾏使⽤.
 *
 *    three -> 标记-整理回收算法:
 *       类似于标记-清除回收算法,但是在标记-清除回收算法的具体回收操作中进⾏内存回收时,
 *       将存活的对象向内存⼀端移动,达到消除内存碎⽚问题.
 *
 *    four -> 分代收集回收算法:
 *       Sun的HotSpot虚拟机将内存分为新⽣代(堆),⽼年代(堆),永久代(⽅法区,常量池,即时编译代码)⼏个区域,
 *       新⽣代主要使⽤基于复制算法的垃圾回收,⽼年代和永久代主要使⽤标记-整理算法进⾏垃圾回收.
 *       具体每个区域使⽤哪种垃圾回收算法还要视垃圾回收器的实现所制约.
 * }
 *
 * 七种垃圾回收器{
 *      首先有Serial, ParNew, Parallel Scavenge, G1, CMS, Serial Old(MSC), Parallel Old.这七个垃圾回收器
 *      新生代回收器: Serial, ParNew, Parallel Scavenge.
 *      老年代回收器: CMS, Serial Old(MSC), Parallel Old.
 *      整堆回收器:   G1
 *
 *      如图(/Users/apple/IdeaProjects/SuperLearning/src/main/java/com/zhilu/gc/img/七个垃圾回收器.png)
 *      两个回收器之间有连线则回收器之间可以搭配使用.
 *      Serial/Serial Old, Serial/CMS, ParNew/ Serial Old, ParNew / CMS ,Parallel Scavenge/ Serial Old, Parallel Scavenge/ Parallel Old
 *
 *      one -> Serial回收器:
 *          Serial收集器是最基本,发展历史最悠久地收集器.是单线程的收集器.
 *          它在进⾏垃圾收集时,必须暂停其他所有的⼯作线程,直到它收集完成.
 *          Serial收集器依然是虚拟机运⾏在Client模式下默认新⽣代收集器,对于运⾏在Client模式下的虚拟机来说
 *          是⼀个很好的选择.
 *
 *      two -> ParNew回收器:
 *          ParNew收集器其实就是Serial收集器的多线程版本,除了使⽤多线程进⾏垃圾收集之外,其余⾏为包括Serial收集器可⽤的所有控制
 *          参数,收集算法,Stop The World(STW),对象分配规则,回收策略等都与Serial 收集器完全⼀样.
 *          ParNew收集器是许多运⾏在<b>Server</b>模式下的虚拟机中⾸选新⽣代收集器,其中有⼀个与性能⽆关但很重要的原因是,除Serial收集器
 *          之外,⽬前只有ParNew它能与CMS收集器配合⼯作.
 *
 *
 *      three -> Parallel Scavenge回收器:
 *          Parallel Scavenge收集器是⼀个新⽣代收集器,它也是使⽤复制算法的收集器,⼜是并⾏的多线程收集器该收集器的⽬标是达到⼀个
 *          可控制的吞吐量(Throughput).所谓吞吐量就是CPU⽤于运⾏⽤户代码的时间与CPU总消耗时间的⽐值,即 吞吐量=运⾏⽤户代
 *          码时间/(运⾏⽤户代码时间+垃圾收集时间)停顿时间越短就越适合需要与⽤户交互的程序,良好地响应速度能提升⽤户体验,⽽⾼
 *          吞吐量则可⽤⾼效率地利⽤CPU时间,尽快完成程序的运算任务,主要适合在后台运算⽽不需要太多交互的任务.
 *          Parallel Scavenge收集器提供两个参数⽤于精确控制吞吐量,分别是控制最⼤垃圾收起停顿时间的-XX:MaxGCPauseMillis参数以
 *          及直接设置吞吐量⼤⼩的-XX:GCTimeRatio参数,Parallel
 *          Scavenge收集器还有⼀个参数：-XX:+UseAdaptiveSizePolicy.这是⼀个开关参数,当这个参数打开后,就不需要⼿⼯指定新⽣代
 *          的⼤⼩(-Xmn),Eden与Survivor区的⽐例(-XX:SurvivorRatio),晋升⽼年代对象年龄(-XX:PretenureSizeThreshold)等
 *          细节参数,只需要把基本的内存数据设置好(如-Xmx设置最⼤堆),然后使⽤MaxGVPauseMillis参数或GCTimeRation参数给虚拟
 *          机设⽴⼀个优化⽬标.
 *          ⾃适应调节策略也是Parallel Scavenge收集器与ParNew收集器的⼀个重要区别.
 *
 *      four -> Serial Old回收器:
 *          Serial Old是Serial收集器的⽼年代版本,它同样是⼀个单线程收集器,使⽤标记整理算法.这个收集器的主要意义也是在于给Client
 *          模式下的虚拟机使⽤.
 *          如果在Server模式下,主要两⼤⽤途：{
 *              (1)在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使⽤
 *              (2)作为CMS收集器的后备预案,在并发收集发⽣Concurrent Mode Failure(并发模式失败)时使⽤Serial Old收集器的⼯作⼯程
 *          }
 *
 *     five -> Parallel Old回收器:
 *          Parallel Old 是Parallel Scavenge收集器的⽼年代版本,使⽤多线程和“标记-整理”算法.这个收集器在1.6中才开始提供.
 *
 *     six -> CMS回收器:
 *          CMS(Concurrent Mark Sweep)收集器是⼀种以获取最短回收停顿时间为⽬标的收集器.⽬前很⼤⼀部分的Java应⽤集中在互联⽹
 *          站或者B/S系统的服务端上,这类应⽤尤其重视服务器的响应速度,希望系统停顿时间最短,以给⽤户带来较好的体验.CMS收集器
 *          就⾮常符合这类应⽤的需求.
 *          CMS收集器是基于“标记-清除”算法实现的.它的运作过程相对前⾯⼏种收集器来说更复杂⼀些,整个过程分为4个步骤：
 *          (1)初始标记
 *          (2)并发标记
 *          (3)重新标记
 *          (4)并发清除
 *          其中,初始标记,重新标记这两个步骤仍然需要“Stop The World”.
 *          CMS收集器主要优点：并发收集,低停顿.
 *          CMS三个明显的缺点：
 *          (1)CMS收集器对CPU资源⾮常敏感.CPU个数少于4个时,CMS对于⽤户程序的影响就可能变得很⼤,为了应付这种情况,虚拟
 *          机提供了⼀种称为“增量式并发收集器”的CMS收集器变种.所做的事情和单CPU年代PC机操作系统使⽤抢占式来模拟多任务机制
 *          的思想
 *          (2)CMS收集器⽆法处理浮动垃圾,可能出现“Concurrent Mode Failure”失败⽽导致另⼀次Full
 *          GC的产⽣.在JDK1.5的默认设置下,CMS收集器当⽼年代使⽤了68%的空间后就会被激活,这是⼀个偏保守地设置,如果在应⽤中
 *          垃圾年代增长不是太快,可以适当调⾼参数-XX:CMSInitiatingOccupancyFraction的值来提⾼触发百分⽐,以便降低内存回收次数从
 *          ⽽获取更好的性能,在JDK1.6中,CMS收集器的启动阀值已经提升⾄92%.
 *          (3)CMS是基于“标记-清除”算法实现的收集器,收集结束时会有⼤量空间碎⽚产⽣.空间碎⽚过多,可能会出现⽼年代还有很⼤
 *          空间剩余,但是⽆法找到⾜够⼤的连续空间来分配当前对象,不得不提前出发FullGC.为了解决这个问题,CMS收集器提供了⼀个-
 *          XX:+UseCMSCompactAtFullCollection开关参数(默认就是开启的),⽤于在CMS收集器顶不住要进⾏FullGC时开启内存碎⽚合
 *          并整理过程,内存整理的过程是⽆法并发的,空间碎⽚问题没有了,但停顿时间变长了.虚拟机设计者还提供了另外⼀个参数-
 *          XX:CMSFullGCsBeforeCompaction,这个参数是⽤于设置执⾏多少次不压缩的Full
 *          GC后,跟着来⼀次带压缩的(默认值为0,标识每次进⼊Full GC时都进⾏碎⽚整理.
 *
 *     Seven -> G1 回收器:
 *      (1)并⾏与并发
 *      (2)分代收集
 *      (3)空间整理 (标记整理算法,复制算法)
 *      (4)可预测的停顿(G1处处理追求低停顿外,还能建⽴可预测的停顿时间模型,能让使⽤者明确指定在⼀个长度为M毫秒的时间⽚
 *         段内,消耗在垃圾收集上的时间不得超过N毫秒,这⼏乎已经实现Java(RTSJ)的来及收集器的特征)
 *       使⽤G1收集器时,Java堆的内存布局是整个规划为多个⼤⼩相等的独⽴区域(Region),虽然还保留有新⽣代和⽼年代的概念,但新
 *       ⽣代和⽼年代不再是物理隔离的了,它们都是⼀部分Region的集合.
 *       G1收集器之所以能建⽴可预测的停顿时间模型,是因为它可以有计划地避免在整个Java堆中进⾏全区域的垃圾收集.G1跟踪各个
 *       Region⾥⾯的垃圾堆积的价值⼤⼩(回收所获取的空间⼤⼩以及回收所需要的时间的经验值),在后台维护⼀个优先列表,每次根据
 *       允许的收集时间,优先回收价值最⼤的Region(这也就是Garbage-First名称的⼜来).这种使⽤区域划分内存空间以及有优先级的
 *       区域回收⽅式,保证了G1收集器在有限的时间内可以获取尽量可能⾼的回机效率.
 *       G1 内存“化整为零”的思路
 *       在GC根节点的枚举范围中加⼊Remembered Set即可保证不对全堆扫描也不会遗漏.
 *       如果不计算维护Remembered Set的操作,G1收集器的运作⼤致可划分为⼀下步骤：
 *          (1)初始标记
 *          (2)并发标记
 *          (3)最终标记
 *          (4)筛选回收
 * }
 * <p></p>
 * 补充:RTSJ(Real-Time Specification For Java) Java实时规范.
 * 问: Java实时规范到底是什么?也就是说,它与常规" Java SE或Java EE规范有何不同?
 * 答: 实时计算的核心是可预测性,即系统将始终在所需的时间范围内执行的知识.
 * 基本上,这是常规VM(以及它的俗套GC)无法实现的,因此需要其他规范:
 * Java实时规范 (RTSJ)或JSR 1,指定Java如何 系统应该实时运行上下文,并且是在几种情况下开发的.来自Java专家多年的经验和实时域.
 * RTSJ旨在无缝地扩展任何Java系列-是否Java平台标准版(Java SE); Java平台微型版(Java ME);或Java平台,企业版(Java EE)
 * 和其他Java版本 要求任何 实现同时通过JSR 1 技术兼容性套件(TCK)和 平台的TCK-Java SE, Java ME或Java EE-它在其上
 */
public class GarbageCollection {
    public static void main(String[] args) {
        System.out.println("Hello, GarbageCollection");
    }
}
