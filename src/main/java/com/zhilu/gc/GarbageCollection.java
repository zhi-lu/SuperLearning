package com.zhilu.gc;

/**
 * @author apple
 * @version jdk1.8
 *
 * 对于垃圾回收的部分.
 *
 * 什么是垃圾,为什么JVM需要进行垃圾回收:首先垃圾的定义当我们对象不在被引用所指向的时候就满足了垃圾的定义.通俗的来说就是我们
 * 创建的大部分对象是根据程序方法的执行所创建的,我们方法执行完毕我们创建的大部分对象可能就不会在被二次或者多次使用了.
 * 这种对象不会在内存中主动的被清除,导致这类对象在JVM的内存所占的比例越来越多.如果不及时清除,从而会导致其他对象的
 * 创建和JVM工作的性能.所以必须有这么一个东西去清除我们程序中所产生的"垃圾".从而保证我们的JVM能够正常的执行工作.
 * 所以我们JVM的垃圾回收因此而生.
 *
 * 如何判断一个对象是否可以被回收:{
 *     one -> 引用计数法 原理:引用计数法为对象添加一个引用计数器.然后用一块额外的内存空间去保存我们对象被引用的次数.
 *     当对象每有一个地方引用它时,那我们对该对象的引用计数就会加1,反之每有一个引用失效时,我们对该对象的引用计数就会减1,
 *     当对象的引用次数为0时,那么我们可以认为这个对象是不会被再次使用了,通过这种方式我们能快速直观的定位到这些可回收的对象,
 *     从而进行清理.
 *     缺点:i -> 无法解决循环引用的问题:引用计数法虽然很直观高效,但是通过引用计数法是没办法扫描到一种特殊情况下的"可回收"对象,
 *                 这种特殊情况就是对象循环引用的时候,比如A对象引用了B,B对象引用了A,除此之外他们两个没有被任何其他对象引用,
 *                 那么其实这部分对象也属于"可回收"的对象,但是通过引用计数法是没办法定位的.垃圾清理不掉,很容易就出现OOM了,这是很致命的,所以被淘汰掉了.
 *          ii -> 另外一个方面是引用计数法需要额外的空间记录每个对象的被引用的次数,这个引用数也需要去额外的维护.
 *
 *     two -> 可达性分析法 原理:可达性分析法是通过以所有的"GC Roots"对象为出发点,如果无法通过GC Roots的引用追踪到的对象,那我们认为这些对象就不会再次被使用了.
 *                           现在主流的程序语言都是通过可达性分析法来判断对象是否存活的.
 *                       <============================================================================>
 *                       哪些对象对象我们称之为"GC Roots"对象呢? 当然普通的对象肯定是不行的,如果要作为GC Roots 对象那么它自身肯定得满足一个条件,
 *                       那就是他自己一定在很长一段时间内都不会被GC 回收掉.那么只有满足这个条件的对象才可能作为GC Roots了.
 *                       GC Roots的类型大致如下:{
 *                           i    -> 虚拟机栈中的本地变量所引用的对象.
 *                           ii   -> 方法区中静态属性所引用的对象.
 *                           iii  -> 方法区中常量属性所引用的对象
 *                           iv   -> 本地方法(Native方法)引用的对象
 *                           v    -> 虚拟机内部的引用对象(类加载器,基本数据对应的Class对象,异常对象)
 *                           vi   -> 所有被同步锁(Synchronized)持有的对象.
 *                           vii  -> 描述虚拟机内部情况的对象.
 *                           viii -> 垃圾搜集器所引用的对象
 *                       }
 * }
 *
 * 首先GarbageCollection(垃圾回收)依托垃圾回收算法和相关的垃圾回收器.
 * 四种垃圾回收算法{
 *    one -> 标记-清除回收算法
 *      可分为两步{
 *          第⼀步:标记出可以回收的对象.
 *          第⼆步:统⼀清理可以回收的对象内存.
 *          }
 *
 *    two -> 标记-复制回收算法:
 *      将内存分为(⼤⼩相等)两部分,每次只使⽤其中⼀块进⾏内存分配,当内存使⽤完后,就触发GC,
 *      将存活的对象直接复制到另⼀块空闲的内存中,然后对当前使⽤的内存块⼀次性清除所有,然后转到另⼀块内存进⾏使⽤.
 *
 *    three -> 标记-整理回收算法:
 *       类似于标记-清除回收算法,但是在标记-清除回收算法的具体回收操作中进⾏内存回收时,
 *       将存活的对象向内存⼀端移动,达到消除内存碎⽚问题.
 *
 *    four -> 分代收集回收算法:
 *       Sun的HotSpot虚拟机将内存分为新⽣代(堆),⽼年代(堆),永久代(⽅法区,常量池,即时编译代码)⼏个区域,
 *       新⽣代主要使⽤基于复制算法的垃圾回收,⽼年代和永久代主要使⽤标记-整理算法进⾏垃圾回收.
 *       具体每个区域使⽤哪种垃圾回收算法还要视垃圾回收器的实现所制约.
 * }
 * 四种回收算法的优缺点和适合的场景{
 *     one -> 标记-清除回收算法:
 *      优点和适用场景:该算法优点的特点就是简单,执行的速度特别快,适合用于可回收对象不多的这种情况.
 *      缺点:1,会造成不连续的内存空间:就像上图清除后的内存区域一样,清除后内存会有很多不连续的空间,
 *             这也就是我们常说的空间碎片(内碎片),这样的空间碎片太多不仅不利于我们下次分配,而且当有大对象创建的时候
 *             我们明明有可以容纳的总空间,但是空间都不是连续地造成对象无法分配,从而不得不提前触发GC,
 *             2,性能不稳定:内存中需要回收的对象,当内存中大量对象都是需要回收的时候,通常这些对象可能比较分散,
 *             所以清除的过程会比较耗时,这个时候清理的速度就会比较慢了,
 *
 *   two -> 标记-复制回收算法:
 *      背景:标记清除算法最大问题是会造成空间碎片,并且只适合需要回收的对象比较多的场景,
 *      那么针对这个问题就衍生了标记复制算法,标记复制算法专门针对这两个问题进行了解决,
 *      标记清除算法的关注点在可回收的对象身上,而标记复制算法的关注点则放在了存活的对象身上,
 *      通过把存活的对象放挪到一个固定的区域,然后对其他区域的对象进行统一清理,
 *
 *      原理:首先它把年轻代内存划分出三块区域,一块用于存放新创建的对象叫Eden区,另两块为Survivor(From 和 To)Survivor
 *      通常比例为(8:1:1),用于存放存活的对象分别叫 S1区和S2区,回收的时候会有两种情况,一种是把Eden和S1区的存活对象复制到S2区,
 *      第二种是把Eden和S2区的存活对象复制到S1区 ,也就是说S1区和S2这两块区域同时只会有一块使用,
 *      通过这种方式保证始终会有一块空白的q区域用于下次GC时存放存活的对象,而且原来的区域不需要考虑保留存活的对象,
 *      所以可以直接一次性清除所有对象,这要既简单直接同时也保证了清除后的内存区域的内存连续性,
 *
 *      优点:标记复制算法解决了标记清除算法的空间碎片问题,并且采用移动存活对象的方式,每次清除针对的都是一整块内存,
 *      所以清除可回收对象的效率也比较高,但因为要移动对象所以这里会耗费一部分时间,所以标记复制算法的效率还是会低于标记清除算法
 *
 *      缺点:1,会浪费一部分空间:总是会有一块空闲的内存区域是利用不到的,这也造成了资源的浪费,
 *          2,存活对象多会非常耗时:因为复制移动对象的过程是比较耗时的,这个适合不仅需要移动对象本身还需要修改使用了这些对象的引用地址,
 *          所以当存活对象多的场景会非常耗时,这也提示我们标记复制法比较适合存活对象较少的场景,
 *          3,需要担保机制:因为复制区总会有一块空间的浪费,而为了减少浪费空间太多,所以我们会把复制区的空间分配控制在很小的区间,
 *             但是空间太小又会产生一个问题,就是在存活的对象比较多的时候,这时复制区的空间可能不够容纳这些对象,
 *             这时就需要借一些空间来保证容纳这些对象,这种从其他地方借内存的方式我们称它为担保机制,
 *
 *      担保机制-分担机制:
 *          一般情况下,复制算法将内存空间按照容量划分为两块,两块内存交替使用,当一块内存使用完的时候,
 *          就先将存活的对象逐一复制到另一块未使用的内存,然后将当前使用的这块内存一次性清理掉,
 *          极端情况下,对象全部存活,但是因为两块内存一样大,所以可以装得下,
 *          为了提高内存利用率,有人提出了复制收集算法的改进方案（如下图所示）,将内存空间按照8:1:1的比例划分为3块（比例可以调整）,
 *          称较大的一块为Eden,较小的两块为Survivor,两个Survivor交替着配合Eden一起使用,每当需要进行垃圾回收,
 *          先将存活的对象复制到保留的Survivor,然后将Eden和之前使用的Survivor一起清理掉,由于Survivor的内存空间较小,极端情况下可能不够保存存活下来的对象,
 *          为了解决这个问题,需要提供一块额外的空间进行分配担保——把保存不下的对象存储到额外空间,
 *
 *
 *     three -> 标记-整理回收算法:
 *         背景:标记复制算法是完美地补齐了标记清除算法的短板,即解决了空间碎片的问题,又适合使用在大部分对象都是可回收的场景,
 *         但是问题是标记复制算法并不适用于存活对象多的场景,如果使用标记清除算法来处理,那么空间碎片又是一个无法忍受的问题,
 *         有了具体的场景和问题,所以就有了标记整理算法,它是专门针对于存活对象多的情况下进行垃圾收集当然同时需要要避免产生空间碎片,
 *
 *         原理:标记整理算法分为标记和整理两个阶段,标记阶段会先把存活的对象和可回收的对象标记出来；
 *              标记完之后就是进行整理了,这个阶段会把存活的对象往内存的一端移动,移动完对象后再清除可回收的对象,
 *
 *         优点:标记整理法最大的特点就是解决了标记清除法的空间碎片问题,同时也不至于像标记复制法需要空闲的内存空间,所以它非常适合存活对象多的场景,
 *         缺点:标记整理法是三种垃圾回收算法中性能最低的一种,因为标记整理法在移动对象的时候不仅需要移动对象,还要额外的维护对象的引用的地址,
 *             这个过程可能要对内存经过几次的扫描定位才能完成,做的事情越多那么必然消耗的时间也越多,
 *
 *    four -> 分代收集回收算法:
 *       
 *       年轻代适合的回收算法:
 *          one -> 标记-复制回收算法
 *                 特点:收集速度快,可以避免空间碎片,但是有空间浪费,存活对象较多的情况下复制对象的过程等会非常耗时,而且需要担保机制,
 *                 适合场景:只有少量对象存活的场景,这也正是新生代对象的特点,所以一般新生代的垃圾回收器基本都会选择标记复制法,
 *  
 *      老年代适合的回收算法:
 *          one -> 标记-清除回收算法
 *                 特点:简单,收集速度快,但会有空间碎片(内碎片),空间碎片会导致后面的GC频率增加,
 *                 适合场景:只有小部分对象需要进行回收的,适用于老年代的垃圾回收,因为老年代一般存活对象会比回收对象要多,
 *
 *          two -> 标记-整理回收算法:
 *                 特点:相对于标记复制法不会浪费内存空间,相对标记清除法则可以避免空间碎片,但是速度比其他两个算法慢,
 *                 适合场景:内存吃紧,又要避免空间碎片的场景,老年代想要避免空间碎片问题的话通常会使用标记整理法,
 * }
 * 七种垃圾回收器{
 *      首先有Serial, ParNew, Parallel Scavenge, G1, CMS, Serial Old(MSC), Parallel Old.这七个垃圾回收器
 *      新生代回收器: Serial, ParNew, Parallel Scavenge.
 *      老年代回收器: CMS, Serial Old(MSC), Parallel Old.
 *      整堆回收器:   G1
 *
 *      如图(/Users/apple/IdeaProjects/SuperLearning/src/main/java/com/zhilu/gc/img/七个垃圾回收器.png)
 *      两个回收器之间有连线则回收器之间可以搭配使用.
 *      Serial/Serial Old, Serial/CMS, ParNew/ Serial Old, ParNew / CMS ,Parallel Scavenge/ Serial Old, Parallel Scavenge/ Parallel Old
 *
 *      one -> Serial回收器:
 *          Serial收集器是最基本,发展历史最悠久地收集器.是单线程的收集器.
 *          它在进⾏垃圾收集时,必须暂停其他所有的⼯作线程,直到它收集完成.
 *          Serial收集器依然是虚拟机运⾏在<b>Client</b>模式下默认新⽣代收集器,对于运⾏在Client模式下的虚拟机来说
 *          是⼀个很好的选择.
 *
 *      two -> ParNew回收器:
 *          ParNew收集器其实就是Serial收集器的多线程版本,除了使⽤多线程进⾏垃圾收集之外,其余⾏为包括Serial收集器可⽤的所有控制
 *          参数,收集算法,Stop The World(STW),对象分配规则,回收策略等都与Serial 收集器完全⼀样.
 *          ParNew收集器是许多运⾏在<b>Server</b>模式下的虚拟机中⾸选新⽣代收集器,其中有⼀个与性能⽆关但很重要的原因是,除Serial收集器
 *          之外,⽬前只有ParNew它能与CMS收集器配合⼯作.
 *
 *
 *      three -> Parallel Scavenge回收器:
 *          Parallel Scavenge收集器是⼀个新⽣代收集器,它也是使⽤复制算法的收集器,⼜是并⾏的多线程收集器该收集器的⽬标是达到⼀个
 *          可控制的吞吐量(Throughput).所谓吞吐量就是CPU⽤于运⾏⽤户代码的时间与CPU总消耗时间的⽐值,即 吞吐量=运⾏⽤户代
 *          码时间/(运⾏⽤户代码时间+垃圾收集时间)停顿时间越短就越适合需要与⽤户交互的程序,良好地响应速度能提升⽤户体验,⽽⾼
 *          吞吐量则可⽤⾼效率地利⽤CPU时间,尽快完成程序的运算任务,主要适合在后台运算⽽不需要太多交互的任务.
 *          Parallel Scavenge收集器提供两个参数⽤于精确控制吞吐量,分别是控制最⼤垃圾收起停顿时间的-XX:MaxGCPauseMillis参数以
 *          及直接设置吞吐量⼤⼩的-XX:GCTimeRatio参数,Parallel
 *          Scavenge收集器还有⼀个参数:-XX:+UseAdaptiveSizePolicy.这是⼀个开关参数,当这个参数打开后,就不需要⼿⼯指定新⽣代
 *          的⼤⼩(-Xmn),Eden与Survivor区的⽐例(-XX:SurvivorRatio),晋升⽼年代对象年龄(-XX:PretenureSizeThreshold)等
 *          细节参数,只需要把基本的内存数据设置好(如-Xmx设置最⼤堆),然后使⽤MaxGVPauseMillis参数或GCTimeRation参数给虚拟
 *          机设⽴⼀个优化⽬标.
 *          ⾃适应调节策略也是Parallel Scavenge收集器与ParNew收集器的⼀个重要区别.
 *
 *      four -> Serial Old回收器:
 *          Serial Old是Serial收集器的⽼年代版本,它同样是⼀个单线程收集器,使⽤标记整理算法.这个收集器的主要意义也是在于给Client
 *          模式下的虚拟机使⽤.
 *          如果在Server模式下,主要两⼤⽤途:{
 *              (1)在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使⽤
 *              (2)作为CMS收集器的后备预案,在并发收集发⽣Concurrent Mode Failure(并发模式失败)时使⽤Serial Old收集器的⼯作⼯程
 *          }
 *
 *     five -> Parallel Old回收器:
 *          Parallel Old 是Parallel Scavenge收集器的⽼年代版本,使⽤多线程和“标记-整理”算法.这个收集器在1.6中才开始提供.
 *
 *     six -> CMS回收器:
 *          CMS(Concurrent Mark Sweep)收集器是⼀种以获取最短回收停顿时间为⽬标的收集器.⽬前很⼤⼀部分的Java应⽤集中在互联⽹
 *          站或者B/S(Browser/Server)系统的服务端上,这类应⽤尤其重视服务器的响应速度,希望系统停顿时间最短,以给⽤户带来较好的体验.CMS收集器
 *          就⾮常符合这类应⽤的需求.
 *          CMS收集器是基于“标记-清除”算法实现的.它的运作过程相对前⾯⼏种收集器来说更复杂⼀些,整个过程分为4个步骤:
 *          (1)初始标记
 *          (2)并发标记
 *          (3)重新标记(再次标记)
 *          (4)并发清除
 *          其中,初始标记,重新标记(再次标记)这两个步骤仍然需要“Stop The World”.
 *          CMS收集器主要优点:并发收集,低停顿.
 *          CMS三个明显的缺点:
 *          (1)CMS收集器对CPU资源⾮常敏感.CPU个数少于4个时,CMS对于⽤户程序的影响就可能变得很⼤,为了应付这种情况,虚拟
 *          机提供了⼀种称为“增量式并发收集器”的CMS收集器变种.所做的事情和单CPU年代PC机操作系统使⽤抢占式来模拟多任务机制
 *          的思想
 *          (2)CMS收集器⽆法处理浮动垃圾,可能出现“Concurrent Mode Failure”失败⽽导致另⼀次Full
 *          GC的产⽣.在JDK1.5的默认设置下,CMS收集器当⽼年代使⽤了68%的空间后就会被激活,这是⼀个偏保守地设置,如果在应⽤中
 *          垃圾年代增长不是太快,可以适当调⾼参数-XX:CMSInitiatingOccupancyFraction的值来提⾼触发百分⽐,以便降低内存回收次数从
 *          ⽽获取更好的性能,在JDK1.6中,CMS收集器的启动阀值已经提升⾄92%.
 *          (3)CMS是基于“标记-清除”算法实现的收集器,收集结束时会有⼤量空间碎⽚产⽣.空间碎⽚过多,可能会出现⽼年代还有很⼤
 *          空间剩余,但是⽆法找到⾜够⼤的连续空间来分配当前对象,不得不提前出发FullGC.为了解决这个问题,CMS收集器提供了⼀个-
 *          XX:+UseCMSCompactAtFullCollection开关参数(默认就是开启的),⽤于在CMS收集器顶不住要进⾏FullGC时开启内存碎⽚合
 *          并整理过程,内存整理的过程是⽆法并发的,空间碎⽚问题没有了,但停顿时间变长了.虚拟机设计者还提供了另外⼀个参数-
 *          XX:CMSFullGCsBeforeCompaction,这个参数是⽤于设置执⾏多少次不压缩的Full
 *          GC后,跟着来⼀次带压缩的(默认值为0,标识每次进⼊Full GC时都进⾏碎⽚整理.
 *
 *     Seven -> G1 回收器:
 *      (1)并⾏与并发
 *      (2)分代收集
 *      (3)空间整理 (标记整理算法,复制算法)
 *      (4)可预测的停顿(G1处处理追求低停顿外,还能建⽴可预测的停顿时间模型,能让使⽤者明确指定在⼀个长度为M毫秒的时间⽚
 *         段内,消耗在垃圾收集上的时间不得超过N毫秒,这⼏乎已经实现Java(RTSJ)的来及收集器的特征)
 *       使⽤G1收集器时,Java堆的内存布局是整个规划为多个⼤⼩相等的独⽴区域(Region),虽然还保留有新⽣代和⽼年代的概念,但新
 *       ⽣代和⽼年代不再是物理隔离的了,它们都是⼀部分Region的集合. 而且在Region中存在一类特殊的空间Humongous,专门用来存储
 *       大对象.什么是大对象,我们G1认为当对象超过Region的一半则认为该对象为大对象,每个Region的大小可以通过参数-XX：G1HeapRegionSize设定,
 *       取值范围为1MB～32MB,且应为2的N次幂.而对于那些超过了整个Region容量的超级大对象,将会被存放在N个连续的Humongous Region之中,
 *       G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待.
 *       G1收集器之所以能建⽴可预测的停顿时间模型,是因为它可以有计划地避免在整个Java堆中进⾏全区域的垃圾收集.G1跟踪各个
 *       Region⾥⾯的垃圾堆积的价值⼤⼩(回收所获取的空间⼤⼩以及回收所需要的时间的经验值),在后台维护⼀个优先列表,每次根据
 *       允许的收集时间,优先回收价值最⼤的Region(这也就是Garbage-First名称的⼜来).这种使⽤区域划分内存空间以及有优先级的
 *       区域回收⽅式,保证了G1收集器在有限的时间内可以获取尽量可能⾼的回机效率.
 *       G1 内存“化整为零”的思路
 *       在GC根节点的枚举范围中加⼊Remembered Set即可保证不对全堆扫描也不会遗漏.
 *       如果不计算维护Remembered Set的操作,G1收集器的运作⼤致可划分为⼀下步骤:
 *          (1)初始标记
 *          (2)并发标记
 *          (3)最终标记
 *          (4)筛选回收
 * }
 * <p></p>
 * 补充:RTSJ(Real-Time Specification For Java) Java实时规范.
 * 问: Java实时规范到底是什么?也就是说,它与常规" Java SE或Java EE规范有何不同?
 * 答: 实时计算的核心是可预测性,即系统将始终在所需的时间范围内执行的知识.
 * 基本上,这是常规VM(以及它的俗套GC)无法实现的,因此需要其他规范:
 * Java实时规范 (RTSJ)或JSR 1,指定Java如何 系统应该实时运行上下文,并且是在几种情况下开发的.来自Java专家多年的经验和实时域.
 * RTSJ旨在无缝地扩展任何Java系列-是否Java平台标准版(Java SE); Java平台微型版(Java ME);或Java平台,企业版(Java EE)
 * 和其他Java版本 要求任何 实现同时通过JSR 1 技术兼容性套件(TCK)和 平台的TCK-Java SE, Java ME或Java EE-它在其上
 * <p></p>
 * 补充:对于垃圾回收算法的三色标记回收算法(G1和CMS回收器主要使用的回收算法)的补充
 *     描述:什么是三色标记回收算法,三色标记回收算法是一种标记回收算法,该算法显著的特征就是让JVM不发生和短暂发生STW(Stop The World).
 *         回收JVM内存存在的JVM,现在主流的垃圾回收器G1和CMS才用该算法对垃圾进行回收.
 *
 *     三色标记回收算法的过程:
 *       黑色:代表该对象以及对象下的属性全都被标记了 (这是我们程序需要的属性,不应该被清除)
 *       灰色:代表该对象被标记了但对象下的属性都没有标记 (需在在对象中寻找垃圾)
 *       白色:代表对象没有被标记(需要回收的对象)
 *
 *     三色标记回收算法的问题:
 *       对象漏标:在三色标记回收算法图中,由于是并发标记,我们已经标记标记了C对象,但是在对象C中使用了D.但D没有被标记,就会
 *               出现冲突这种情况.
 *
 *     CMS回收器解决三色标记回收算法的对象漏标问题:
 *          在解决三色标记回收算法出现的对象漏标,我们的CMS提出增量更新的方法(Increment Update)
 *          当未被标记的对象在被引用的时候,如果它是被黑色的对象所引用的时候,这时候对象就会被标记为灰色,当第二次GC的时候
 *          GC线程再去标记它的属性对象.
 *
 *    G1回收器解决三色标记回收算法的对象漏标问题:
 *          G1回收器在应对漏标时,采用了SATB (Snapshot At The Beginning).
 *          one   ->  在标记开始的时候标成一个快照图标记存活对象
 *          two   ->  在一个引用断开后,要将此引用推到GC的堆栈中,保证对象还能被GC线程扫描到(通过在 write barrier 里把所有旧地引用所指向的对象都变成非白的).
 *          three ->  配合Remembered Set,去扫描哪些Region引用到当前的白色对象,若没有引用到当前对象,则回收.
 *
 */
public class GarbageCollection {
    public static void main(String[] args) {
        System.out.println("Hello, GarbageCollection");
    }
}
