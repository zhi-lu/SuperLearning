package com.zhilu.jmm;

/**
 * @author apple
 * @version jdk1.8
 *
 * 对于Java内存模型分析.
 *
 * 1: 类加载区子系统方法区: 类加载子系统负责从文件系统或者网络中加载Class信息,加载的类信息存放于一块称为方法区的内存空间.
 *                    除了类的信息外,方法区中可能还会放运行时常量池信息,包括字符串字面量和数字量(这部分常量信息是class文件中常量池部分的内存映射)
 *
 * 2: Java堆: 在虚拟机启动的时候建立,它是Java程序最主要的内存工作区域.
 *          几乎所有的Java对象实例都存放在Java堆中,堆空间是所有线程共享的,这是一块与Java应用密切相关的内存空间.
 *
 * 3: 直接内存: Java的NIO库允许Java程序使用直接内存.直接内存是在Java堆外的,直接向系统申请的内存空间.
 *            通常访问直接内存的速度会优于Java堆.因此出于性能的考虑,读写频繁的场合可能会考虑使用直接内存.由于直接内存在Java堆外,
 *            因此它的大小不会直接受限于Xmx指定的最大堆大小(物理内存的1/4(<1GB)),但是系统内存是有限的,Java堆和直接内存的总和依然受限于操作系统能给出的最大内存.
 *            (实际大小内存取决于你的物理内存,大小肯定是大于堆的)
 *
 * 4: 垃圾回收系统: 垃圾回收系统是Java虚拟机的重要组成部分,垃圾回收器可以对方法区,Java堆和直接内存进行回收.
 *                其中Java堆是垃圾收集器的工作重点.和C/C++不同,Java中所有的对象空间释放都是隐式的,
 *                也就是说,Java中没有类似free()或者delete()这样的函数释放指定内存区域.对于不再使用的垃圾对象,
 *                垃圾回收系统(守护线程)会在后台默默工作,默默查找,标识并释放垃圾对象,完成包括Java堆,方法区何直接内存中的全自动化管理.
 *
 * 5: Java栈: 每一个Java虚拟机线程都有一个私有的Java栈,一个线程的Java栈在线程创建的时候被创建,Java栈中保存着帧信息.
 *           Java栈中保存着局部变量,方法参数,同时和Java方法的调用,返回密切相关
 *
 * 6: 本地方法栈: 本地方法栈和Java栈非常类似,最大的不同在于Java栈用于方法的调用,而本地方法栈则用于本地方法的调用,
 *              作为Java虚拟机的重要扩展,Java虚拟机允许Java直接调用本地方法(通常使用C/C++编写)(每个操作系统都有不同的本地方法)
 *
 * 7: PC(Program Counter): PC寄存器也是每一个线程私有的空间,Java虚拟机会为每一个Java线程创建PC寄存器.
 *                        在任意时刻,一个Java线程总是在执行一个方法,这个正在被执行的方法称为当前方法.
 *                        如果方法不是本地方法,PC寄存器就会指向当前正在被执行的指令.如果当前方法是本地方法,
 *                        那么PC寄存器的值就是undefined(可以理解为区分调用的是本地方法还是当前方法)
 *
 * 8: 执行引擎: 执行引擎是Java虚拟机的最核心组件之一,它负责执行虚拟机的字节码,现代虚拟机为了提高执行效率,
 *           会使用即时编译技术(JIT),将方法编译成机器码后再执行.
 * 
 * Java虚拟机: Jvm内存分代策略,Java虚拟机根据对象存活的周期不同,把堆内存划分为几块,
 *            一般分为新生代,老年代和永久代(使用HotSpot)这就是JVM的内存分代策略.
 *
 * 为什么要分代:
 *      堆内存是虚拟机管理的内存中最大的一块,也是垃圾回收最频繁的一块区域,我们程序所有的对象实例都存放在堆内存中.
 *      给堆内存分代是为了提高对象内存分配和垃圾回收的效率.试想一下,如果堆内存没有区域划分,所有的新创建的对象和生命周期很长的对象放在一起,
 *      随着程序的执行,堆内存需要频繁进行垃圾收集,而每次回收都要遍历所有的对象,遍历这些对象所花费的时间代价是巨大的,会严重影响我们的GC效率.
 *
 *      有了内存分代,情况就不同了,新创建的对象会在新生代中分配内存,经过多次回收仍然存活下来的对象存放在老年代中.
 *      静态属性,类信息等存放在永久代中,新生代中的对象存活时间短,只需要在新生代区域中频繁进行GC,
 *      老年代中对象生命周期长,内存回收的频率相对比较低,不需要频繁进行回收,永久代中回收效果太差,一般不进行垃圾回收,
 *      还可以根据不同年代的特点采用合适的垃圾收集算法.分代收集大大提升了收集效率,这些都是内存分代带来的好处.
 *
 * 内存分代划分:
 *     Java虚拟机将堆内存划分为新生代,老年代和永久代,永久代是HotSpot虚拟机特有的概念,它采用永久代的方法来实现方法区,
 *     其他的虚拟机实现没有这一概念,而且HotSpot也有取消永久代的趋势,在JDK1.7中HotSpot已经开始了”去永久化“,吧原本放在永久代的字符串常量池移除.
 *     永久代主要存放常量,类信息,静态变量等数据,与垃圾回收关系不大,新生代和老年代是垃圾回收的主要区域.
 *
 * 新生代(Young Generation):
 *     新生代的对象优先存放在新生代中,新生代对象朝生夕死,存活率很低,在新生代中,常规应用进行一次垃圾收集一般可以回收70%~95%的空间,回收率很高.
 *
 *     HotSpot将新生代分为三块,一块较大的Eden空间和两快较小的Survivor空间,默认比例为8:1:1.划分的目的是因为HotSpot采用复制算法来回收新生代,
 *     设置这个比例是为了充分利用内存空间,减少浪费.新生成的对象在Eden区分配(大对象除外,大对象直接进入老年代),
 *     当Eden区没有足够的空间进行分配时,虚拟机将发起一次Minor GC.GC开始时,对象只会存在于Eden区和From Survivor区时空的(作为保留区域).
 *     GC进行时,Eden区中所有存活的对象都会被复制到To Survivor区,而在From Survivor区中,仍存活的对象会根据他们的年龄决定去向,
 *     年龄值到达年龄阀值(默认为15,新生代中的对象每熬过一轮垃圾回收,年龄值就会加1,GC分代年龄存储在对象的header中)的对象会被移到老年代中,
 *     没有达到阀值得对象都会被复制到To Survivor区.接着清空Eden区和From Survivor区,新生代中存活的对象都在To Survivor区.
 *     接着,From Survivor区和To Survivor区会交换他们的角色,也就是新的To Survivor区就是上次GC清空的From Survivor区,新的From Survivor区就是上次的GC的To Survivor区,
 *     总之,不管怎么样都会保证To Survivor区在一轮GC后是空的.GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存对象时,
 *     需要依赖老年代进行分配担保,将这些对象存放在老年代中.
 *
 * 老年代(Old Generation):
 *     在新生代中经历了多次(具体看虚拟机配置的阀值)GC后仍然存活下来的对象会进入老年代.
 *     老年代中的对象生命周期较长,存活率比较高,在老年代中进行GC的频率相对而言较低,而且回收的速度也比较慢.
 *
 * 永久代(Permanent Generation):
 *     永久代存储类信息,常量,静态变量,即时编译器编译后的代码等数据,对这一区域而言,Java虚拟机规范支出可以不进行垃圾收集,
 *     一般而言不会进行垃圾回收.
 *
 */
public class JavaMemoryModel {
    public static void main(String[] args) {
        System.out.println("Hello, JavaMemoryModel");
    }
}
